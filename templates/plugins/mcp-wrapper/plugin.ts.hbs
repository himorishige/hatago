import type { HatagoPlugin } from '@hatago/core'
import {
  {{camelCase name}}Config,
  {{camelCase name}}ConfigSchema,
} from './{{kebabCase name}}.config'
import { create{{titleCase name}}Client } from './{{kebabCase name}}.client'
import type { {{titleCase name}}ClientOptions } from './{{kebabCase name}}.types'

/**
 * {{description}}
 *
 * This plugin wraps the {{mcpServerName}} external MCP server and provides
 * its tools and resources through the Hatago interface.
 *
 * @author {{author}}
 */
export const {{camelCase name}}Plugin: HatagoPlugin = async ({ server, app, env, getBaseUrl }) => {
  // Parse and validate configuration
  const config = {{camelCase name}}ConfigSchema.parse({
    name: '{{name}}',
    transport: env?.{{toUpperCase (snakeCase name)}}_TRANSPORT || '{{transport}}',
    
    // STDIO configuration
    {{#if (eq transport 'stdio')}}
    stdio: {
      command: '{{mcpCommand}}',
      args: [{{#each mcpArgs}}'{{this}}'{{#unless @last}}, {{/unless}}{{/each}}],
      env: {
        {{#if (ne authType 'none')}}
        {{authToken}}: env?.{{authToken}}
        {{/if}}
      }
    },
    {{/if}}

    // HTTP configuration
    {{#if (eq transport 'http')}}
    http: {
      endpoint: env?.{{toUpperCase (snakeCase name)}}_ENDPOINT || '{{mcpServerEndpoint}}',
      autoStart: env?.{{toUpperCase (snakeCase name)}}_AUTO_START !== 'false',
      autoStartConfig: {
        command: 'npx {{mcpServerName}} --port',
        preferredPort: parseInt(env?.{{toUpperCase (snakeCase name)}}_PORT as string) || {{mcpServerPort}},
        portRange: {
          min: {{portRangeMin}},
          max: {{portRangeMax}}
        }
      }
      {{#if (ne authType 'none')}},
      authToken: env?.{{authToken}}
      {{/if}}
    },
    {{/if}}

    {{#if namespace}}
    namespace: env?.{{toUpperCase (snakeCase name)}}_NAMESPACE || '{{namespace}}',
    {{/if}}
    {{#if caching}}
    cache: {
      enabled: env?.{{toUpperCase (snakeCase name)}}_CACHE_ENABLED !== 'false',
      ttl: parseInt(env?.{{toUpperCase (snakeCase name)}}_CACHE_TTL as string) || 300000
    },
    {{/if}}
    {{#if healthCheck}}
    healthCheck: {
      enabled: env?.{{toUpperCase (snakeCase name)}}_HEALTH_CHECK !== 'false',
      interval: parseInt(env?.{{toUpperCase (snakeCase name)}}_HEALTH_INTERVAL as string) || 60000
    }
    {{/if}}
  })

  // Validate required configuration
  {{#if (eq transport 'stdio')}}
  if (config.transport === 'stdio' && !config.stdio) {
    throw new Error('STDIO configuration is required when transport is stdio')
  }
  {{/if}}
  {{#if (eq transport 'http')}}
  if (config.transport === 'http' && !config.http) {
    throw new Error('HTTP configuration is required when transport is http')
  }
  {{#if (ne authType 'none')}}
  if (config.transport === 'http' && !config.http?.authToken) {
    throw new Error('{{authToken}} environment variable is required for HTTP transport')
  }
  {{/if}}
  {{/if}}

  // Create MCP client (functional factory pattern)
  const clientOptions: {{titleCase name}}ClientOptions = {
    transport: config.transport,
    timeout: 30000,
    
    // STDIO options
    stdio: config.stdio,
    
    // HTTP options
    http: config.http ? {
      ...config.http,
      {{#if (ne authType 'none')}}
      auth: config.http.authToken ? {
        type: '{{authType}}',
        {{#if (eq authType 'bearer')}}
        token: config.http.authToken
        {{/if}}
      } : undefined
      {{/if}}
    } : undefined,

    {{#if caching}}
    cache: config.cache,
    {{/if}}
    {{#if healthCheck}}
    healthCheck: config.healthCheck
    {{/if}}
  }
  
  const client = create{{titleCase name}}Client(clientOptions)

  try {
    // Connect to external MCP server
    const connectionTarget = config.transport === 'stdio' 
      ? `${config.stdio?.command} ${config.stdio?.args?.join(' ')}`
      : config.http?.endpoint || 'auto-start'
      
    console.log(`[${config.name}] Connecting to MCP server via ${config.transport.toUpperCase()}: ${connectionTarget}...`)
    await client.connect()
    console.log(`[${config.name}] Successfully connected to MCP server`)

    // Load available tools and register them
    const tools = await client.listTools()
    console.log(`[${config.name}] Found ${tools.length} tools`)

    for (const tool of tools) {
      {{#if namespace}}
      const toolName = config.namespace ? `${config.namespace}.${tool.name}` : tool.name
      {{else}}
      const toolName = tool.name
      {{/if}}

      server.registerTool({
        name: toolName,
        description: `${tool.description} (via {{mcpServerName}})`,
        inputSchema: tool.inputSchema
      }, async (args) => {
        try {
          console.log(`[${config.name}] Calling tool: ${tool.name}`)
          return await client.callTool(tool.name, args)
        } catch (error) {
          console.error(`[${config.name}] Tool ${tool.name} failed:`, error)
          throw error
        }
      })
    }

    // Load available resources and register them
    const resources = await client.listResources()
    console.log(`[${config.name}] Found ${resources.length} resources`)

    for (const resource of resources) {
      {{#if namespace}}
      const resourceUri = config.namespace ? `${config.namespace}://${resource.uri}` : resource.uri
      {{else}}
      const resourceUri = resource.uri
      {{/if}}

      server.registerResource({
        uri: resourceUri,
        name: resource.name,
        description: `${resource.description} (via {{mcpServerName}})`,
        mimeType: resource.mimeType
      }, async () => {
        try {
          console.log(`[${config.name}] Reading resource: ${resource.uri}`)
          return await client.readResource(resource.uri)
        } catch (error) {
          console.error(`[${config.name}] Resource ${resource.uri} failed:`, error)
          throw error
        }
      })
    }

    {{#if hasHttpRoutes}}
    // Register HTTP routes if app is available
    if (app) {
      app.get('/{{kebabCase name}}/status', async (c) => {
        return c.json({
          plugin: '{{name}}',
          status: 'connected',
          transport: config.transport,
          tools: tools.length,
          resources: resources.length,
          timestamp: new Date().toISOString()
        })
      })

      app.get('/{{kebabCase name}}/tools', async (c) => {
        return c.json({
          tools: tools.map(tool => ({
            name: tool.name,
            description: tool.description,
            inputSchema: tool.inputSchema
          }))
        })
      })
    }
    {{/if}}

    console.log(`[${config.name}] Plugin initialized successfully`)

  } catch (error) {
    console.error(`[${config.name}] Failed to initialize plugin:`, error)
    throw error
  }
}

export default {{camelCase name}}Plugin