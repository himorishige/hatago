/**
 * Google OAuth provider for {{titleCase name}} plugin
 */

import type { OAuthConfig, OAuthToken } from '../oauth-types'
import { TokenManager } from '../token-manager'
import { performOAuthFlow } from '../oauth-flow'

/**
 * Google OAuth configuration
 */
export interface GoogleOAuthConfig extends OAuthConfig {
  provider: 'google'
  clientId?: string
  clientSecret?: string
  scope?: string
  accessType?: 'online' | 'offline'
  prompt?: 'none' | 'consent' | 'select_account'
  includeGrantedScopes?: boolean
  loginHint?: string  // Email to pre-fill
  hostedDomain?: string  // Restrict to domain
}

/**
 * Google-specific token
 */
export interface GoogleToken extends OAuthToken {
  scope: string
  token_type: 'Bearer'
  id_token?: string  // OpenID Connect token
  refresh_token?: string  // Only with offline access
  expires_in: number
  expires_at: number
}

/**
 * Google user info
 */
export interface GoogleUserInfo {
  id: string
  email: string
  verified_email: boolean
  name: string
  given_name?: string
  family_name?: string
  picture?: string
  locale?: string
  hd?: string  // Hosted domain
}

/**
 * Google OAuth helper
 */
export class GoogleOAuthProvider {
  private config: GoogleOAuthConfig
  private tokenManager: TokenManager

  constructor(config: Partial<GoogleOAuthConfig> = {}) {
    this.config = {
      provider: 'google',
      authorizationUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
      tokenUrl: 'https://oauth2.googleapis.com/token',
      revokeUrl: 'https://oauth2.googleapis.com/revoke',
      userInfoUrl: 'https://www.googleapis.com/oauth2/v2/userinfo',
      scope: config.scope || 'openid profile email',
      accessType: config.accessType || 'offline',
      prompt: config.prompt || 'consent',
      includeGrantedScopes: config.includeGrantedScopes !== false,
      pkce: true,
      autoRefresh: true,
      ...config
    }

    this.tokenManager = new TokenManager()
    
    // Register refresh callback
    if (this.config.autoRefresh) {
      this.tokenManager.registerRefreshCallback(
        'google',
        this.refreshAccessToken.bind(this)
      )
    }
  }

  /**
   * Get authorization URL
   */
  getAuthorizationUrl(state: string, codeChallenge?: string): string {
    const params = new URLSearchParams({
      client_id: this.config.clientId!,
      redirect_uri: this.config.redirectUri!,
      response_type: 'code',
      scope: this.config.scope!,
      state,
      access_type: this.config.accessType!,
      include_granted_scopes: String(this.config.includeGrantedScopes)
    })

    if (this.config.prompt) {
      params.set('prompt', this.config.prompt)
    }

    if (this.config.loginHint) {
      params.set('login_hint', this.config.loginHint)
    }

    if (this.config.hostedDomain) {
      params.set('hd', this.config.hostedDomain)
    }

    // PKCE support
    if (codeChallenge && this.config.pkce) {
      params.set('code_challenge', codeChallenge)
      params.set('code_challenge_method', 'S256')
    }

    return `${this.config.authorizationUrl}?${params.toString()}`
  }

  /**
   * Exchange authorization code for token
   */
  async exchangeCodeForToken(
    code: string,
    codeVerifier?: string
  ): Promise<GoogleToken> {
    const params = new URLSearchParams({
      client_id: this.config.clientId!,
      client_secret: this.config.clientSecret!,
      code,
      redirect_uri: this.config.redirectUri!,
      grant_type: 'authorization_code'
    })

    // Add PKCE verifier if available
    if (codeVerifier && this.config.pkce) {
      params.set('code_verifier', codeVerifier)
    }

    const response = await fetch(this.config.tokenUrl!, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: params.toString()
    })

    const data = await response.json()

    if (data.error) {
      throw new Error(`Google OAuth error: ${data.error_description || data.error}`)
    }

    const token: GoogleToken = {
      access_token: data.access_token,
      token_type: data.token_type || 'Bearer',
      scope: data.scope,
      expires_in: data.expires_in,
      expires_at: Date.now() + (data.expires_in * 1000),
      refresh_token: data.refresh_token,
      id_token: data.id_token
    }

    // Store token
    await this.tokenManager.setToken('google', token)

    return token
  }

  /**
   * Refresh access token
   */
  async refreshAccessToken(oldToken: OAuthToken): Promise<GoogleToken> {
    if (!oldToken.refresh_token) {
      throw new Error('No refresh token available')
    }

    const params = new URLSearchParams({
      client_id: this.config.clientId!,
      client_secret: this.config.clientSecret!,
      refresh_token: oldToken.refresh_token,
      grant_type: 'refresh_token'
    })

    const response = await fetch(this.config.tokenUrl!, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: params.toString()
    })

    const data = await response.json()

    if (data.error) {
      throw new Error(`Failed to refresh token: ${data.error_description || data.error}`)
    }

    const token: GoogleToken = {
      access_token: data.access_token,
      token_type: data.token_type || 'Bearer',
      scope: data.scope || oldToken.scope,
      expires_in: data.expires_in,
      expires_at: Date.now() + (data.expires_in * 1000),
      // Google doesn't return a new refresh token, keep the old one
      refresh_token: data.refresh_token || oldToken.refresh_token,
      id_token: data.id_token
    }

    return token
  }

  /**
   * Get user info
   */
  async getUserInfo(accessToken: string): Promise<GoogleUserInfo> {
    const response = await fetch(this.config.userInfoUrl!, {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    })

    if (!response.ok) {
      throw new Error(`Failed to get user info: ${response.statusText}`)
    }

    return response.json()
  }

  /**
   * Validate token
   */
  async validateToken(accessToken: string): Promise<boolean> {
    try {
      const response = await fetch(
        `https://oauth2.googleapis.com/tokeninfo?access_token=${accessToken}`
      )

      if (!response.ok) {
        return false
      }

      const data = await response.json()
      
      // Check if token is not expired
      const expiresIn = parseInt(data.expires_in || '0')
      return expiresIn > 0
    } catch {
      return false
    }
  }

  /**
   * Revoke token
   */
  async revokeToken(token: string): Promise<void> {
    const params = new URLSearchParams({
      token
    })

    const response = await fetch(this.config.revokeUrl!, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: params.toString()
    })

    if (!response.ok && response.status !== 400) {
      // 400 means token was already invalid
      throw new Error(`Failed to revoke token: ${response.statusText}`)
    }

    // Remove from storage
    await this.tokenManager.deleteToken('google')
  }

  /**
   * Get stored token
   */
  async getStoredToken(): Promise<GoogleToken | null> {
    return await this.tokenManager.getToken('google') as GoogleToken | null
  }

  /**
   * Create provider from environment
   */
  static fromEnvironment(): GoogleOAuthProvider | null {
    // Check for API key first (simpler auth)
    const apiKey = process.env['GOOGLE_API_KEY'] || 
                   process.env['{{toUpperCase (snakeCase name)}}_GOOGLE_API_KEY']
    
    if (apiKey) {
      const provider = new GoogleOAuthProvider()
      
      // Store as a simple bearer token
      const token: GoogleToken = {
        access_token: apiKey,
        token_type: 'Bearer',
        scope: 'api_key',
        expires_in: 0,
        expires_at: Number.MAX_SAFE_INTEGER  // API keys don't expire
      }
      
      provider.tokenManager.setToken('google', token)
      return provider
    }

    // Check for OAuth token
    const accessToken = process.env['GOOGLE_ACCESS_TOKEN'] || 
                       process.env['{{toUpperCase (snakeCase name)}}_GOOGLE_TOKEN']
    
    if (accessToken) {
      const provider = new GoogleOAuthProvider({
        clientId: process.env['{{toUpperCase (snakeCase name)}}_GOOGLE_CLIENT_ID'],
        clientSecret: process.env['{{toUpperCase (snakeCase name)}}_GOOGLE_CLIENT_SECRET']
      })

      const token: GoogleToken = {
        access_token: accessToken,
        token_type: 'Bearer',
        scope: process.env['GOOGLE_OAUTH_SCOPE'] || 'openid profile email',
        expires_in: 3600,
        expires_at: Date.now() + (3600 * 1000),
        refresh_token: process.env['GOOGLE_REFRESH_TOKEN']
      }

      provider.tokenManager.setToken('google', token)
      return provider
    }

    // Check for service account (future implementation)
    const serviceAccount = process.env['GOOGLE_APPLICATION_CREDENTIALS']
    if (serviceAccount) {
      console.warn('Service account authentication not yet implemented')
      return null
    }

    return null
  }

  /**
   * Get headers for API requests
   */
  async getAuthHeaders(): Promise<Record<string, string>> {
    const token = await this.getStoredToken()
    
    if (!token) {
      throw new Error('No Google token available')
    }

    // Check if using API key
    if (token.scope === 'api_key') {
      return {
        'X-Goog-Api-Key': token.access_token
      }
    }

    // Standard OAuth bearer token
    return {
      'Authorization': `Bearer ${token.access_token}`
    }
  }

  /**
   * Test API access
   */
  async testAccess(): Promise<boolean> {
    try {
      const token = await this.getStoredToken()
      if (!token) {
        return false
      }

      // For API keys, just check if it exists
      if (token.scope === 'api_key') {
        return true
      }

      // For OAuth tokens, validate
      return await this.validateToken(token.access_token)
    } catch {
      return false
    }
  }

  /**
   * Decode ID token (for OpenID Connect)
   */
  decodeIdToken(idToken: string): any {
    try {
      const parts = idToken.split('.')
      if (parts.length !== 3) {
        throw new Error('Invalid ID token format')
      }

      const payload = parts[1]
      const decoded = Buffer.from(payload, 'base64url').toString('utf-8')
      return JSON.parse(decoded)
    } catch (error) {
      throw new Error(`Failed to decode ID token: ${error.message}`)
    }
  }

  /**
   * Get token info
   */
  async getTokenInfo(accessToken: string): Promise<any> {
    const response = await fetch(
      `https://oauth2.googleapis.com/tokeninfo?access_token=${accessToken}`
    )

    if (!response.ok) {
      throw new Error(`Failed to get token info: ${response.statusText}`)
    }

    return response.json()
  }

  /**
   * Perform full OAuth flow
   */
  async performAuthFlow(): Promise<GoogleToken> {
    if (!this.config.clientId || !this.config.clientSecret) {
      throw new Error('Client ID and secret required for OAuth flow')
    }

    const token = await performOAuthFlow(this.config)
    
    // Store token with refresh callback
    await this.tokenManager.setToken('google', token as GoogleToken)
    
    return token as GoogleToken
  }

  /**
   * Check if authentication is needed
   */
  async needsAuthentication(): Promise<boolean> {
    const token = await this.getStoredToken()
    
    if (!token) {
      return true
    }

    // For API keys, always valid
    if (token.scope === 'api_key') {
      return false
    }

    // Check if token is expired
    if (this.tokenManager.isTokenExpired(token)) {
      // Try to refresh
      if (token.refresh_token && this.config.autoRefresh) {
        try {
          await this.refreshAccessToken(token)
          return false
        } catch {
          return true
        }
      }
      return true
    }

    // Validate token
    const isValid = await this.validateToken(token.access_token)
    return !isValid
  }
}

/**
 * Google OAuth configuration helper
 */
export function createGoogleConfig(overrides: Partial<GoogleOAuthConfig> = {}): GoogleOAuthConfig {
  return {
    provider: 'google',
    authorizationUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
    tokenUrl: 'https://oauth2.googleapis.com/token',
    revokeUrl: 'https://oauth2.googleapis.com/revoke',
    userInfoUrl: 'https://www.googleapis.com/oauth2/v2/userinfo',
    scope: 'openid profile email',
    accessType: 'offline',
    prompt: 'consent',
    includeGrantedScopes: true,
    pkce: true,
    autoRefresh: true,
    ...overrides
  }
}