/**
 * GitHub OAuth provider for {{titleCase name}} plugin
 */

import type { OAuthConfig, OAuthToken } from '../oauth-types'
import { TokenManager } from '../token-manager'
import { performOAuthFlow } from '../oauth-flow'

/**
 * GitHub OAuth configuration
 */
export interface GitHubOAuthConfig extends OAuthConfig {
  provider: 'github'
  clientId?: string
  clientSecret?: string
  scope?: string
  allowSignup?: boolean
  login?: string  // Suggest specific account
}

/**
 * GitHub-specific token
 */
export interface GitHubToken extends OAuthToken {
  scope: string
  token_type: 'bearer'
}

/**
 * GitHub OAuth helper
 */
export class GitHubOAuthProvider {
  private config: GitHubOAuthConfig
  private tokenManager: TokenManager

  constructor(config: Partial<GitHubOAuthConfig> = {}) {
    this.config = {
      provider: 'github',
      authorizationUrl: 'https://github.com/login/oauth/authorize',
      tokenUrl: 'https://github.com/login/oauth/access_token',
      userInfoUrl: 'https://api.github.com/user',
      scope: config.scope || 'repo read:org read:user',
      pkce: true,
      autoRefresh: false,  // GitHub doesn't support refresh tokens
      ...config
    }

    this.tokenManager = new TokenManager()
  }

  /**
   * Get authorization URL
   */
  getAuthorizationUrl(state: string, codeChallenge?: string): string {
    const params = new URLSearchParams({
      client_id: this.config.clientId!,
      redirect_uri: this.config.redirectUri!,
      scope: this.config.scope!,
      state,
      allow_signup: String(this.config.allowSignup !== false)
    })

    if (this.config.login) {
      params.set('login', this.config.login)
    }

    // GitHub doesn't support PKCE yet, but we prepare for it
    if (codeChallenge && this.config.pkce) {
      params.set('code_challenge', codeChallenge)
      params.set('code_challenge_method', 'S256')
    }

    return `${this.config.authorizationUrl}?${params.toString()}`
  }

  /**
   * Exchange authorization code for token
   */
  async exchangeCodeForToken(
    code: string,
    codeVerifier?: string
  ): Promise<GitHubToken> {
    const params = new URLSearchParams({
      client_id: this.config.clientId!,
      client_secret: this.config.clientSecret!,
      code,
      redirect_uri: this.config.redirectUri!
    })

    // Add PKCE verifier if available
    if (codeVerifier && this.config.pkce) {
      params.set('code_verifier', codeVerifier)
    }

    const response = await fetch(this.config.tokenUrl!, {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: params.toString()
    })

    const data = await response.json()

    if (data.error) {
      throw new Error(`GitHub OAuth error: ${data.error_description || data.error}`)
    }

    const token: GitHubToken = {
      access_token: data.access_token,
      token_type: data.token_type || 'bearer',
      scope: data.scope,
      // GitHub tokens don't expire by default
      expires_at: undefined
    }

    // Store token
    await this.tokenManager.setToken('github', token)

    return token
  }

  /**
   * Get user info
   */
  async getUserInfo(accessToken: string): Promise<any> {
    const response = await fetch('https://api.github.com/user', {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Accept': 'application/vnd.github.v3+json'
      }
    })

    if (!response.ok) {
      throw new Error(`Failed to get user info: ${response.statusText}`)
    }

    return response.json()
  }

  /**
   * Validate token
   */
  async validateToken(accessToken: string): Promise<boolean> {
    try {
      const response = await fetch('https://api.github.com/user', {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Accept': 'application/vnd.github.v3+json'
        }
      })

      return response.ok
    } catch {
      return false
    }
  }

  /**
   * Revoke token (GitHub specific endpoint)
   */
  async revokeToken(accessToken: string): Promise<void> {
    // GitHub requires app authentication to revoke tokens
    if (!this.config.clientId || !this.config.clientSecret) {
      throw new Error('Client ID and secret required to revoke GitHub tokens')
    }

    const auth = Buffer.from(
      `${this.config.clientId}:${this.config.clientSecret}`
    ).toString('base64')

    const response = await fetch(
      `https://api.github.com/applications/${this.config.clientId}/token`,
      {
        method: 'DELETE',
        headers: {
          'Authorization': `Basic ${auth}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          access_token: accessToken
        })
      }
    )

    if (!response.ok && response.status !== 404) {
      throw new Error(`Failed to revoke token: ${response.statusText}`)
    }

    // Remove from storage
    await this.tokenManager.deleteToken('github')
  }

  /**
   * Get stored token
   */
  async getStoredToken(): Promise<GitHubToken | null> {
    return await this.tokenManager.getToken('github') as GitHubToken | null
  }

  /**
   * Create provider from environment
   */
  static fromEnvironment(): GitHubOAuthProvider | null {
    const token = TokenManager.createTokenFromEnv(
      'GITHUB_PERSONAL_ACCESS_TOKEN',
      'github'
    )

    if (!token) {
      return null
    }

    const provider = new GitHubOAuthProvider({
      clientId: process.env['{{toUpperCase (snakeCase name)}}_GITHUB_CLIENT_ID'],
      clientSecret: process.env['{{toUpperCase (snakeCase name)}}_GITHUB_CLIENT_SECRET']
    })

    // Store the token
    provider.tokenManager.setToken('github', token)

    return provider
  }

  /**
   * Get headers for API requests
   */
  async getAuthHeaders(): Promise<Record<string, string>> {
    const token = await this.getStoredToken()
    
    if (!token) {
      throw new Error('No GitHub token available')
    }

    return {
      'Authorization': `Bearer ${token.access_token}`,
      'Accept': 'application/vnd.github.v3+json'
    }
  }

  /**
   * Test API access
   */
  async testAccess(): Promise<boolean> {
    try {
      const token = await this.getStoredToken()
      if (!token) {
        return false
      }

      return await this.validateToken(token.access_token)
    } catch {
      return false
    }
  }

  /**
   * Perform full OAuth flow
   */
  async performAuthFlow(): Promise<GitHubToken> {
    if (!this.config.clientId || !this.config.clientSecret) {
      throw new Error('Client ID and secret required for OAuth flow')
    }

    const token = await performOAuthFlow(this.config)
    
    // Store token
    await this.tokenManager.setToken('github', token as GitHubToken)
    
    return token as GitHubToken
  }

  /**
   * Check if authentication is needed
   */
  async needsAuthentication(): Promise<boolean> {
    const token = await this.getStoredToken()
    
    if (!token) {
      return true
    }

    // Check if token is valid
    const isValid = await this.validateToken(token.access_token)
    return !isValid
  }
}

/**
 * GitHub OAuth configuration helper
 */
export function createGitHubConfig(overrides: Partial<GitHubOAuthConfig> = {}): GitHubOAuthConfig {
  return {
    provider: 'github',
    authorizationUrl: 'https://github.com/login/oauth/authorize',
    tokenUrl: 'https://github.com/login/oauth/access_token',
    userInfoUrl: 'https://api.github.com/user',
    scope: 'repo read:org read:user',
    pkce: true,
    autoRefresh: false,
    ...overrides
  }
}